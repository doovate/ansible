- name: Make sure necessary packages are installed
  apt:
    name: "{{ item }}"
    state: latest
    update_cache: yes
  loop:
    - libxdamage1
    - libgbm1
    - libxkbcommon0
    - pip

- name: Install the docker launcher from pip
  pip:
    name:
      - "{{ docker_launcher }}"
    state: latest
    break_system_packages: true

- name: Clone repo to temporary location
  ansible.builtin.git:
    repo: https://github.com/doovate-beta/dv-odoo-docker.git
    dest: "{{ odoo_path }}"
    depth: 1
    version: main
    force: yes
  register: git_updated

- name: Create the necessary directories for the Odoo docker containers
  file:
    path: "{{ odoo_path }}/{{ item }}"
    state: directory
    mode: '0777'
  loop:
    - addons
    - cache
    - config

- name: Create the necessary files for the Odoo docker containers
  copy:
    content: ""
    dest: "{{ odoo_path }}/{{ item }}"
    force: no
    mode: '0755'
  loop:
    - cache/addons_cache.json
    - addons/requirements.txt

- name: Create .env file from template
  template:
    src: odoo.env.j2
    dest: "{{ odoo_path }}/.env"
    mode: '0644'
  register: env_file
  notify: relaunch containers

- name: Create postgresql.conf file from template
  template:
    src: postgresql.conf.j2
    dest: "{{ odoo_path }}/config/postgresql.conf"
    mode: '0644'
  register: pg_conf_file
  notify: relaunch containers

- name: Create odoo.conf file from template
  template:
    src: odoo.conf.j2
    dest: "{{ odoo_path }}/config/odoo.conf"
    mode: '0644'
  register: odoo_conf_file
  notify: relaunch containers

- name: Configure containers to use available resources
  command:
    chdir: "{{ odoo_path }}"
    cmd: "{{ docker_launcher }} config auto-config"
  when: git_output.changed or env_file.changed
  ignore_errors: yes

- name: Initialize addon map
  set_fact:
    selected_addon_map: { }
    temp_addons_dir: "/tmp/odoo_addons_{{ inventory_hostname }}"

- name: Extract repository names from repo_list
  set_fact:
    repo_names: "{{ repo_list | default([]) | map('split', '|') | map('first') | map('regex_replace', '.*modulepack-(.*)\\.git$', '\\1') | list }}"

- name: Check for duplicate repositories in different branches
  fail:
    msg: "Error: El repositorio '{{ item }}' está configurado en múltiples ramas diferentes. Solo se permite una rama por repositorio."
  when: repo_names | select('equalto', item) | list | length > 1
  loop: "{{ repo_names | unique }}"

- name: Build addon map from repo_list
  set_fact:
    selected_addon_map: >-
      {{
        selected_addon_map | combine({
          (item.split('|')[0] | regex_replace('.*modulepack-(.*)\\.git$', '\\1')) + '-' + item.split('|')[1]: {
            'url': 'https://' + item.split('|')[0],
            'branch': item.split('|')[1]
          }
        })
      }}
  loop: "{{ repo_list | default([]) }}"

- name: Show selected addons
  debug:
    msg: "Selected addons from repo_list: {{ selected_addon_map | dict2items | map(attribute='key') | list }}"

- name: Create temporary directory for addon cloning
  ansible.builtin.file:
    path: "{{ temp_addons_dir }}"
    state: directory
    mode: '0755'

- name: Clone addon repositories to temp from custom map
  ansible.builtin.git:
    repo: "{{ item.value.url }}"
    dest: "{{ temp_addons_dir }}/{{ item.key }}"
    version: "{{ item.value.branch }}"
    depth: 1
    force: yes
  loop: "{{ selected_addon_map | dict2items }}"
  when: selected_addon_map | length > 0
  register: git_clone_results

- name: Copy addons content from temp to final location (only if updated)
  ansible.posix.synchronize:
    src: "{{ temp_addons_dir }}/{{ item.item.key }}/"
    dest: "{{ odoo_path }}/addons/"
    delete: no
    recursive: yes
  loop: "{{ git_clone_results.results }}"
  loop_control:
    label: "{{ item.item.key }}"
  delegate_to: "{{ inventory_hostname }}"
  when:
    - item.changed | default(false)
    - not item.skipped | default(false)
  notify: relaunch containers
  no_log: "{{ not (item.changed | default(false)) }}"

- name: Find all requirements.txt files in cloned addons
  ansible.builtin.find:
    paths: "{{ temp_addons_dir }}/{{ item.key }}"
    patterns: "requirements.txt"
    recurse: yes
  loop: "{{ selected_addon_map | dict2items }}"
  register: requirements_files
  when:
    - selected_addon_map | length > 0

- name: Flatten requirements files list
  set_fact:
    all_requirements_files: >-
      {{
        requirements_files.results |
        selectattr('files', 'defined') |
        map(attribute='files') |
        flatten |
        list
      }}
  when: requirements_files.results is defined

- name: Read all requirements.txt files
  ansible.builtin.slurp:
    src: "{{ item.path }}"
  loop: "{{ all_requirements_files }}"
  register: requirements_contents
  when: all_requirements_files | default([]) | length > 0
  ignore_errors: yes

- name: Combine all requirements into a single list
  set_fact:
    combined_requirements: [ ]
  when: requirements_contents is defined

- name: Process each requirements file
  set_fact:
    combined_requirements: >-
      {{
        combined_requirements +
        (item.content | b64decode | split('\n') |
        map('trim') |
        select('match', '^[^#\s].*') |
        list)
      }}
  loop: "{{ requirements_contents.results | default([]) }}"
  when:
    - item.content is defined
    - not item.failed | default(false)
  ignore_errors: yes

- name: Remove duplicates and sort
  set_fact:
    combined_requirements: "{{ combined_requirements | unique | sort }}"
  when: combined_requirements is defined

- name: Check if requirements.txt exists
  ansible.builtin.stat:
    path: "{{ odoo_path }}/addons/requirements.txt"
  register: existing_requirements

- name: Read existing requirements.txt if exists
  ansible.builtin.slurp:
    src: "{{ odoo_path }}/addons/requirements.txt"
  register: existing_requirements_content
  when: existing_requirements.stat.exists

- name: Calculate new requirements content
  set_fact:
    new_requirements_content: "{{ combined_requirements | join('\n') }}\n"
  when:
    - combined_requirements is defined
    - combined_requirements | length > 0

- name: Check if requirements have changed
  set_fact:
    requirements_changed: >-
      {{
        not existing_requirements.stat.exists or
        (existing_requirements_content.content | default('') | b64decode) != new_requirements_content
      }}
  when: new_requirements_content is defined

- name: Create/Update combined requirements.txt
  ansible.builtin.copy:
    content: "{{ new_requirements_content }}"
    dest: "{{ odoo_path }}/addons/requirements.txt"
    mode: '0644'
  when:
    - new_requirements_content is defined
    - requirements_changed | default(false)
  notify: relaunch containers

- name: Create the folder for the list of base addons to be installed
  ansible.builtin.file:
    path: "{{ odoo_path }}/addons/base_addons_list/"
    state: directory
    mode: '0755'
  when: base_addons | default([]) | length > 0

- name: Create the __init__.py file for the list of base addons to be installed
  ansible.builtin.file:
    path: "{{ odoo_path }}/addons/base_addons_list/__init__.py"
    state: touch
    mode: '0644'
  when: base_addons | default([]) | length > 0

- name: Create the manifest file for the list of base addons to be installed
  ansible.builtin.template:
    src: __manifest__.py.j2
    dest: "{{ odoo_path }}/addons/base_addons_list/__manifest__.py"
    mode: '0644'
  when: base_addons | default([]) | length > 0

# Todo: figure out proper permissions for these directories
- name: Set 777 permissions recursively on Odoo writable directories
  file:
    path: "{{ odoo_path }}/{{ item }}"
    mode: '0777'
    recurse: yes
  loop:
    - addons
    - cache
    - config

- name: Obtain container info
  community.docker.docker_container_info:
    name: "{{ compose_project_name }}_{{ item }}"
  loop:
    - db
    - odoo
  register: container_info
  ignore_errors: yes

- name: Check if any container is down or missing
  ansible.builtin.set_fact:
    containers_stopped: true
  when: >
    (container_info.results | selectattr('exists', 'equalto', false) | list | length > 0)
    or
    (container_info.results | selectattr('exists', 'equalto', true) | selectattr('container.State.Running', 'equalto', false) | list | length > 0)

- name: Notify to relaunch if needed
  debug:
    msg: "Containers need to be relaunched"
  when: containers_stopped | default(false)
  changed_when: containers_stopped | default(false)
  notify: relaunch containers
