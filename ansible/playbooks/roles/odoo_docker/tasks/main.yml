- name: Clone repo to temporary location
  ansible.builtin.git:
    repo: https://github.com/doovate-beta/dv-odoo-docker.git
    dest: "{{ odoo_path }}"
    depth: 1
    version: main
    force: yes
  register: git_updated
  notify: relaunch containers

- name: Create the necessary directories for the Odoo docker containers
  file:
    path: "{{ odoo_path }}/{{ item }}"
    state: directory
    mode: '0755'
    owner: tsg
    group: tsg
  loop:
    - addons
    - cache
    - config

- name: Create the necessary files for the Odoo docker containers
  copy:
    content: ""
    dest: "{{ odoo_path }}/{{ item }}"
    force: no
    mode: '0644'
    owner: tsg
    group: tsg
  loop:
    - cache/addons_cache.json
    - addons/requirements.txt

- name: Create .env file from template
  template:
    src: odoo.env.j2
    dest: "{{ odoo_path }}/.env"
    mode: '0644'
    owner: tsg
    group: tsg
  register: env_file
  notify: relaunch containers

- name: Create postgresql.conf file from template
  template:
    src: postgresql.conf.j2
    dest: "{{ odoo_path }}/config/postgresql.conf"
    mode: '0644'
    owner: tsg
    group: tsg
  register: pg_conf_file
  notify: relaunch containers

- name: Read existing odoo.conf if exists
  ansible.builtin.slurp:
    src: "{{ odoo_path }}/config/odoo.conf"
  register: existing_odoo_conf
  ignore_errors: yes

- name: Extract existing admin_passwd
  set_fact:
    existing_admin_passwd: >-
      {{
        (existing_odoo_conf.content | b64decode)
        | regex_search('admin_passwd\s*=\s*(.+)', '\1')
        | first | default('')
      }}
  when: existing_odoo_conf is not failed
  ignore_errors: yes
  register: existing_admin_passwd_extracted

- name: Generate hashed master password
  ansible.builtin.command:
    cmd: python3 -c "from passlib.hash import pbkdf2_sha512; print(pbkdf2_sha512.hash('{{ initial_db_master_pass }}'))"
  register: hashed_master_password
  changed_when: false
  delegate_to: localhost
  when:
    - initial_db_master_pass | default('') != ''
    - existing_admin_passwd | default('') == ''
  become: false

- name: Create odoo.conf file from template
  template:
    src: odoo.conf.j2
    dest: "{{ odoo_path }}/config/odoo.conf"
    mode: '0644'
    owner: tsg
    group: tsg
  register: odoo_conf_file
  notify: relaunch containers

- name: Initialize addon map
  set_fact:
    selected_addon_map: { }
    temp_addons_dir: "/tmp/odoo_addons_{{ inventory_hostname }}"

- name: Build addon map from repo_list
  set_fact:
    selected_addon_map: >-
      {{
        selected_addon_map | combine({
          (item.split('|')[0] | regex_replace('.*modulepack-(.*)\\.git$', '\\1')) + '-' + item.split('|')[1]: {
            'url': item.split('|')[0],
            'branch': item.split('|')[1],
            'visibility': item.split('|')[2]
          }
        })
      }}
  loop: "{{ repo_list | default([]) }}"

- name: Check for duplicate repositories in different branches
  fail:
    msg: "Error: El repositorio '{{ item }}' está configurado en múltiples ramas diferentes."
  when: >-
    selected_addon_map.keys()
    | map('regex_replace', '-[^-]+$', '')
    | select('equalto', item)
    | list | length > 1
  loop: >-
    {{
      selected_addon_map.keys()
      | map('regex_replace', '-[^-]+$', '')
      | unique | list
    }}

- name: Create temporary directory for addon cloning
  ansible.builtin.file:
    path: "{{ temp_addons_dir }}"
    state: directory
    mode: '0755'

- name: Generate GitHub App JWT and get access token
  shell: |
    python3 - <<'EOF'
    import jwt, time, requests, sys

    app_id = '{{ lookup("env", "GIT_CLONE_APP_ID") }}'
    installation_id = '{{ lookup("env", "GIT_CLONE_INSTALLATION_ID") }}'

    private_key = '{{ lookup("env", "GIT_CLONE_APP_KEY") }}'

    payload = {
        'iat': int(time.time()) - 60,
        'exp': int(time.time()) + (10 * 60),
        'iss': app_id
    }

    encoded_jwt = jwt.encode(payload, private_key, algorithm='RS256')

    response = requests.post(
        f'https://api.github.com/app/installations/{installation_id}/access_tokens',
        headers={
            'Authorization': f'Bearer {encoded_jwt}',
            'Accept': 'application/vnd.github.v3+json'
        }
    )

    if response.status_code != 201:
        print(f"ERROR: {response.json()}", file=sys.stderr)
        sys.exit(1)

    print(response.json()['token'])
    EOF
  register: github_token_result

- name: Clone public addon repositories
  ansible.builtin.git:
    repo: "https://{{ item.value.url }}"
    dest: "{{ temp_addons_dir }}/{{ item.key }}"
    version: "{{ item.value.branch }}"
    depth: 1
    force: yes
  loop: "{{ selected_addon_map | dict2items }}"
  when: item.value.visibility == 'pub'

- name: Clone private addon repositories
  ansible.builtin.git:
    repo: "https://x-access-token:{{ github_token_result.stdout }}@{{ item.value.url }}"
    dest: "{{ temp_addons_dir }}/{{ item.key }}"
    version: "{{ item.value.branch }}"
    depth: 1
    force: yes
  loop: "{{ selected_addon_map | dict2items }}"
  when: item.value.visibility == 'priv'
  async: 120
  poll: 0
  register: git_clone_async

- name: Wait for all clones to finish
  async_status:
    jid: "{{ item.ansible_job_id }}"
  loop: "{{ git_clone_async.results }}"
  when: item.ansible_job_id is defined
  register: git_clone_results
  until: git_clone_results.finished
  retries: 30
  delay: 5

- name: Copy addons content from temp to final location (only if changed)
  ansible.posix.synchronize:
    src: "{{ temp_addons_dir }}/{{ item.key }}/"
    dest: "{{ odoo_path }}/addons/"
    delete: no
    recursive: yes
    checksum: yes  # Compare checksums to avoid copying unchanged files
    rsync_opts:
      - "--chown=tsg:tsg"
      - "--exclude=.git"
  loop: "{{ selected_addon_map | dict2items }}"
  loop_control:
    label: "{{ item.key }}"
  delegate_to: "{{ inventory_hostname }}"
  notify: relaunch containers

- name: Find all requirements.txt files in cloned addons
  ansible.builtin.find:
    paths: "{{ temp_addons_dir }}/{{ item.key }}"
    patterns: "requirements.txt"
    recurse: yes
  loop: "{{ selected_addon_map | dict2items }}"
  register: requirements_files
  when:
    - selected_addon_map | length > 0

- name: Flatten requirements files list
  set_fact:
    all_requirements_files: >-
      {{
        requirements_files.results |
        selectattr('files', 'defined') |
        map(attribute='files') |
        flatten |
        list
      }}
  when: requirements_files.results is defined

- name: Read all requirements.txt files
  ansible.builtin.slurp:
    src: "{{ item.path }}"
  loop: "{{ all_requirements_files }}"
  register: requirements_contents
  when: all_requirements_files | default([]) | length > 0
  ignore_errors: yes

- name: Combine all requirements into a single list
  set_fact:
    combined_requirements: [ ]
  when: requirements_contents is defined

- name: Process each requirements file
  set_fact:
    combined_requirements: >-
      {{
        combined_requirements +
        (item.content | b64decode | split('\n') |
        map('trim') |
        select('match', '^[^#\s].*') |
        list)
      }}
  loop: "{{ requirements_contents.results | default([]) }}"
  when:
    - item.content is defined
    - not item.failed | default(false)
  ignore_errors: yes

- name: Remove duplicates and sort
  set_fact:
    combined_requirements: "{{ combined_requirements | unique | sort }}"
  when: combined_requirements is defined

- name: Check if requirements.txt exists
  ansible.builtin.stat:
    path: "{{ odoo_path }}/addons/requirements.txt"
  register: existing_requirements

- name: Read existing requirements.txt if exists
  ansible.builtin.slurp:
    src: "{{ odoo_path }}/addons/requirements.txt"
  register: existing_requirements_content
  when: existing_requirements.stat.exists

- name: Calculate new requirements content
  set_fact:
    new_requirements_content: "{{ combined_requirements | join('\n') }}\n"
  when:
    - combined_requirements is defined
    - combined_requirements | length > 0

- name: Check if requirements have changed
  set_fact:
    requirements_changed: >-
      {{
        not existing_requirements.stat.exists or
        (existing_requirements_content.content | default('') | b64decode) != new_requirements_content
      }}
  when: new_requirements_content is defined

- name: Create/Update combined requirements.txt
  ansible.builtin.copy:
    content: "{{ new_requirements_content }}"
    dest: "{{ odoo_path }}/addons/requirements.txt"
    mode: '0644'
  when:
    - new_requirements_content is defined
    - requirements_changed | default(false)
  notify: relaunch containers

- name: Create the folder for the list of base addons to be installed
  ansible.builtin.file:
    path: "{{ odoo_path }}/addons/base_addons_list/"
    state: directory
    mode: '0755'
    owner: tsg
    group: tsg
  when: base_addons | default([]) | length > 0

- name: Create the __init__.py file for the list of base addons to be installed
  ansible.builtin.file:
    path: "{{ odoo_path }}/addons/base_addons_list/__init__.py"
    state: touch
    mode: '0644'
    owner: tsg
    group: tsg
  when: base_addons | default([]) | length > 0

- name: Create the manifest file for the list of base addons to be installed
  ansible.builtin.template:
    src: __manifest__.py.j2
    dest: "{{ odoo_path }}/addons/base_addons_list/__manifest__.py"
    mode: '0644'
    owner: tsg
    group: tsg
  when: base_addons | default([]) | length > 0